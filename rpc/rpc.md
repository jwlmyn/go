# 一、什么是rpc？
1、屏蔽网络编程细节，调用远端的方法像调用本地一样简单
# 二、rpc通信流程
![image](https://github.com/user-attachments/assets/3a3ff586-4054-4b8e-9cda-3ee5fcb377b9)
1、rpc是一个远程调用，要保证数据的准确性，所以默认一般用TCP进行传输
2、网络传输是以二进制形式进行传输，所以中间有序列化和反序列化过程
3、涉及到动态代理技术，屏蔽具体细节（go语言中用的是反射，没有自带动态代理包）
# 三、可扩展向后兼容的协议
![image](https://github.com/user-attachments/assets/cde9f46d-076e-4e32-8860-c5389a734180)
1、请求头需要包括，消息ID、协议长度、协议版本、序列化方式、消息类型、扩展字段（防止有一些特殊的需求）
2、协议体里面放请求接口和参数
# 四、rpc为什么还要单独设计一个协议，而不用现有的http1.1协议等
1、rpc更多的是应用间的通信，对性能要求较高
2、HTTP数据包大小相对请求数据要大很多，还要加很多无用的内容，比如回车换行符等
3、HTTP属于无状态协议，建立连接后断开，每次请求都要重新连接
4、HTTP2是2015年出来的，grpc底层直接用的HTTP2
# 五、有哪些常用的序列化？
1、JSON，需要额外开销空间大，且没有类型，比如java强类型语言，就需要反射来解决，服务方和客户端发送数据量要较小，否则严重影响性能
2、Hessian，比JSON紧凑，跨语言，但是对java中的一些对象类型不支持
3、Protobuf，不需要通过反射获取类型，序列化后比JSON和Hessian体积要小，序列化和反序列化很快
# 六、RPC框架如何选择序列化？
1、序列化与反序列化的性能效率
2、序列化与反序列化后的空间开销，二进制体积大小
3、序列化协议的通用性和兼容性
4、稳定性和可用率，要考虑是否有很多人用过、升级迭代后这个序列化协议，还可以稳定工作等因素
# 七、RPC框架更倾向于哪种网络IO模型？
1、四种IO模型：同步阻塞，同步非阻塞，IO多路复用、异步非阻塞
2、更倾向于IO多路复用，因为rpc更多应用在高并发场景下，考虑到系统内核、编程语言等
# 八、什么是IO多路复用？
1、多个网络连接IO可以注册到一个复用器（select）上，用户调用后阻塞，但是用户可以在这一个线程中，同时处理多个IO请求
2、好比我们去餐厅吃饭，这次我们是几个人一起去的，我们专门留了一个人在餐厅排号等位，其他人就去逛街了，等排号的朋友通知我们可以吃饭了，我们就直接去享用了。
# 九、什么是零拷贝？
![image](https://github.com/user-attachments/assets/91530da1-38e6-4bdf-ac61-87cf7066fae6)
1、进程每一次读写操作，用户态到内核态一次，内核态到网卡一次，返回数据再有两次，零拷贝就是解决用户态到内核态的过程，CPU的上下文切换，避免这一过程
2、虚拟内存：将用户控件和内核空间的数据都写到一个地方
3、主要两种实现方式：分别是 mmap+write 方式和 sendfile 方式，
mmap是利用了虚拟内存(划分为用户内存和内核内存)映射到用户空间中,sendfile可以直接从磁盘读取到内核中然后直接从内核发送到网卡,不需要进行用户态和内核态的转换拷贝
# 十、静态代理和动态代理
1、静态代理：比如学生交班费，班长统一收取，然后代替学生上交，这时候班长就属于代理类，那么在代理类就可以在执行上交班费前执行一些其他操作，比如班长在每次上交班费钱，夸一下张三最近表现很好，这就属于代理的好处，静态代理是在程序运行之前编译完成，但是静态代理就需要为每一个接口生成一个代理类，第一重复麻烦，第二个就是学生变了，班长也要变，代理类需要修改代码
2、动态代理：不需要为每一个接口去生成一个代理类，很方便的对代理类的函数进行统一的处理，被代码类变化，代理类未必需要变化，第二解决了重复的问题。代码运行时动态生成的。通过聚合方式持有被代理对象的引用，把外部对invoke的调用最终都转为对被代理对象的调用。
# 十一、动态代理：面向接口编程，屏蔽RPC处理流程
![image](https://github.com/user-attachments/assets/3b45a056-200a-4b36-9a8a-7968ff3cc3d7)
动态代理是一种具体的技术框架，那就会涉及到选型。我们可以从这样三个角度去考虑：
1、因为代理类是在运行中生成的，那么代理框架生成代理类的速度、生成代理类的字节码大小等等，都会影响到其性能——生成的字节码越小，运行所占资源就越小。
2、还有就是我们生成的代理类，是用于接口方法请求拦截的，所以每次调用接口方法的时候，都会执行生成的代理类，这时生成的代理类的执行效率就需要很高效。
3、最后一个是从我们的使用角度出发的，我们肯定希望选择一个使用起来很方便的代理类框架，比如我们可以考虑：API 设计是否好理解、社区活跃度、还有就是依赖复杂度等等。
# 十二、RPC的结构设计
![image](https://github.com/user-attachments/assets/0a58837b-ee92-4745-b689-fa9206bec5c1)
1、考虑到可靠性传输，一般采用TCP协议传输，为了屏蔽网络的复杂性，我们单独封装一个模块，叫传输模块
2、用户的请求是基于方法调用，需要传参，那么急需要序列化数据，还要在必要的位置加上“断句”，这里叫协议封装
3、这两个步骤其实都是为了可靠性传输，那么统一封装好，叫协议模块
4、除此之外可以加入压缩功能，提升传输效率，包的大小超过某个阈值，就启动压缩算法。包的大小可以决定包被拆分成多少数据包等等。
5、为了让两个模块能配合工作，需要写一些粘合性的代码，但是这部分代码对开发人员没有意义，我们需要屏蔽具体细节，让调用远程方法像调用本地一样，这部分我们一般叫做 Bootstrap 模块。
6、上面这些最多算是单机版，服务提供方肯定不是单一的机器，是分集群处理请求的，那么就需要有集群模块
7、考虑到可扩展性，那么就引入插件模块，将功能的接口和功能的实现分离，提供接口的默认实现，符合开闭原则，可扩展性好。
# 十三、服务发现
1、服务注册：在服务提供方启动的时候，将对外暴露的接口注册到注册中心之中，注册中心将这个服务节点的 IP 和接口保存下来。
2、服务订阅：在服务调用方启动的时候，去注册中心查找并订阅服务提供方的 IP，然后缓存到本地，并用于后续的远程调用。
# 十四、为什么不使用 DNS？
1、如果 IP 端口下线了，服务调用者不能及时摘除服务节点
2、如果在之前已经上线了一部分服务节点，这时我突然对这个服务进行扩容，那么新上线的服务节点不能及时接收到流量
3、为了提升性能和减少 DNS 服务的压力，DNS 采取了多级缓存机制，一般配置的缓存时间较长
# 十五、基于 ZooKeeper 的服务发现
1、搭建一个 ZooKeeper 集群作为注册中心集群，服务注册的时候只需要服务节点向 ZooKeeper 节点写入注册信息即可，利用 ZooKeeper 的 Watcher 机制完成服务订阅与服务下发功能
2、服务平台管理端先在 ZooKeeper 中创建一个服务根路径，在这个路径再创建服务提供方目录与服务调用方目录
3、当服务提供方发起注册时，会在服务提供方目录中创建一个临时节点，节点中存储该服务提供方的注册信息。
4、当服务调用方发起订阅时，则在服务调用方目录中创建一个临时节点，节点中存储该服务调用方的信息，同时服务调用方 watch 该服务的服务提供方目录中所有的服务节点数据。
5、当服务提供方目录下有节点数据发生变更时，ZooKeeper 就会通知给发起订阅的服务调用方。
# 十六、基于消息总线的最终一致性的注册中心
1、我们知道，ZooKeeper 的一大特点就是强一致性，ZooKeeper 集群的每个节点的数据每次发生更新操作，都会通知其它 ZooKeeper 节点同时执行更新。它要求保证每个节点的数据能够实时的完全一致，这也就直接导致了 ZooKeeper 集群性能上的下降。这就好比几个人在玩传递东西的游戏，必须这一轮每个人都拿到东西之后，所有的人才能开始下一轮，而不是说我只要获得到东西之后，就可以直接进行下一轮了。
2、而 RPC 框架的服务发现，在服务节点刚上线时，服务调用方是可以容忍在一段时间之后（比如几秒钟之后）发现这个新上线的节点的。毕竟服务节点刚上线之后的几秒内，甚至更长的一段时间内没有接收到请求流量，对整个服务集群是没有什么影响的，所以我们可以牺牲掉 CP（强制一致性），而选择 AP（最终一致），来换取整个注册中心集群的性能和稳定性。
3、因为要求最终一致性，我们可以考虑采用消息总线机制。注册数据可以全量缓存在每个注册中心内存中，通过消息总线来同步数据。当有一个注册中心节点接收到服务节点注册时，会产生一个消息推送给消息总线，再通过消息总线通知给其它注册中心节点更新数据并进行服务下发，从而达到注册中心间数据最终一致性，对于获取到消息的在消息回放模块里面回放，只接受大于本地版本号的消息，小于本地版本号的消息直接丢弃，从而实现最终一致性。
# 十七、健康检测的状态
![image](https://github.com/user-attachments/assets/3b2547ee-ba4b-40de-84d6-0a020df54b18)
1、首先，一开始初始化的时候，如果建立连接成功，那就是健康状态，否则就是死亡状态。这里没有亚健康这样的中间态。紧接着，如果健康状态的节点连续出现几次不能响应心跳请求的情况，那就会被标记为亚健康状态，也就是说，服务调用方会觉得它生病了。生病之后（亚健康状态），如果连续几次都能正常响应心跳请求，那就可以转回健康状态，证明病好了。如果病一直好不了，那就会被断定为是死亡节点，死亡之后还需要善后，比如关闭连接。当然，死亡并不是真正死亡，它还有复活的机会。如果某个时间点里，死亡的节点能够重连成功，那它就可以重新被标记为健康状态。
# 十八、健康检测的具体逻辑
1、调用方每个接口的调用频次不一样，有的接口可能 1 秒内调用上百次，有的接口可能半个小时才会调用一次，所以我们不能把简单的把总失败的次数当作判断条件。
2、服务的接口响应时间也是不一样的，有的接口可能 1ms，有的接口可能是 10s，所以我们也不能把 TPS 至来当作判断条件。
3、可用率的计算方式是某一个时间窗口内接口调用成功次数的百分比（成功次数 / 总调用次数）。当可用率低于某个比例就认为这个节点存在问题，把它挪到亚健康列表，这样既考虑了高低频的调用接口，也兼顾了接口响应时间不同的问题。
# 十九、为什么选择路由策略？
1、服务提供方是以集群的方式对外提供服务的，一个接口后面会有多个服务节点，每个节点返回的结果都是一样的，那么在上线的时候，我们一般考虑到上线后可能不符合预期，会进行灰度发布，但是一旦线上出现影响，范围还是挺大的，比如影响到商品的价格等，那么路由策略就是为了减少这种风险
# 二十、如何实现路由策略？
![image](https://github.com/user-attachments/assets/b8eea5a1-54a1-4473-9257-a94180fbd8fb)
![image](https://github.com/user-attachments/assets/8002baa1-fd4f-4ca4-86f8-8a4384e5c0ca)
1、我们刚上线的节点只允许某个IP使用，注册中心把这条规则下发到服务调用方，服务调用方在选择节点的时候，就会选择这个新上线的节点，这样就可以做到让部分服务调用方用到新上线的实例
# 二十一、参数路由
![image](https://github.com/user-attachments/assets/936aa360-0b69-4587-adf9-8ba9c2c2d798)
1、在有些场景下，我们可能还需要更细粒度的路由方式。比如，在升级改造应用的时候，为了保证调用方能平滑地切调用我们的新应用逻辑，在升级过程中我们常用的方式是让新老应用并行运行一段时间，然后通过切流量百分比的方式，慢慢增大新应用承接的流量，直到新应用承担了 100% 且运行一段时间后才能去下线老应用。在流量切换的过程中，为了保证整个流程的完整性，我们必须保证某个主题对象的所有请求都使用同一种应用来承接。假设我们改造的是商品应用，那主题对象肯定是商品 ID，在切流量的过程中，我们必须保证某个商品的所有操作都是用新应用（或者老应用）来完成所有请求的响应。很显然，上面的 IP 路由并不能满足我们这个需求，因为 IP 路由只是限制调用方来源，并不会根据请求参数请求到我们预设的服务提供方节点上去。
2、我们可以给所有的服务提供方节点都打上标签，用来区分新老应用节点。在服务调用方发生请求的时候，我们可以很容易地拿到请求参数，也就是我们例子中的商品 ID，我们可以根据注册中心下发的规则来判断当前商品 ID 的请求是过滤掉新应用还是老应用的节点。因为规则对所有的调用方都是一样的，从而保证对应同一个商品 ID 的请求要么是新应用的节点，要么是老应用的节点。

