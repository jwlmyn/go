# 一、什么是rpc？
1、屏蔽网络编程细节，调用远端的方法像调用本地一样简单
# 二、rpc通信流程
![image](https://github.com/user-attachments/assets/3a3ff586-4054-4b8e-9cda-3ee5fcb377b9)
1、rpc是一个远程调用，要保证数据的准确性，所以默认一般用TCP进行传输
2、网络传输是以二进制形式进行传输，所以中间有序列化和反序列化过程
3、涉及到动态代理技术，屏蔽具体细节（go语言中用的是反射，没有自带动态代理包）
# 三、可扩展向后兼容的协议
![image](https://github.com/user-attachments/assets/cde9f46d-076e-4e32-8860-c5389a734180)
1、请求头需要包括，消息ID、协议长度、协议版本、序列化方式、消息类型、扩展字段（防止有一些特殊的需求）
2、协议体里面放请求接口和参数
# 四、rpc为什么还要单独设计一个协议，而不用现有的http1.1协议等
1、rpc更多的是应用间的通信，对性能要求较高
2、HTTP数据包大小相对请求数据要大很多，还要加很多无用的内容，比如回车换行符等
3、HTTP属于无状态协议，建立连接后断开，每次请求都要重新连接
4、HTTP2是2015年出来的，grpc底层直接用的HTTP2
# 五、有哪些常用的序列化？
1、JSON，需要额外开销空间大，且没有类型，比如java强类型语言，就需要反射来解决，服务方和客户端发送数据量要较小，否则严重影响性能
2、Hessian，比JSON紧凑，跨语言，但是对java中的一些对象类型不支持
3、Protobuf，不需要通过反射获取类型，序列化后比JSON和Hessian体积要小，序列化和反序列化很快
# 六、RPC框架如何选择序列化？
1、序列化与反序列化的性能效率
2、序列化与反序列化后的空间开销，二进制体积大小
3、序列化协议的通用性和兼容性
4、稳定性和可用率，要考虑是否有很多人用过、升级迭代后这个序列化协议，还可以稳定工作等因素
# 七、RPC框架更倾向于哪种网络IO模型？
1、四种IO模型：同步阻塞，同步非阻塞，IO多路复用、异步非阻塞
2、更倾向于IO多路复用，因为rpc更多应用在高并发场景下，考虑到系统内核、编程语言等
# 八、什么是IO多路复用？
1、多个网络连接IO可以注册到一个复用器（select）上，用户调用后阻塞，但是用户可以在这一个线程中，同时处理多个IO请求
2、好比我们去餐厅吃饭，这次我们是几个人一起去的，我们专门留了一个人在餐厅排号等位，其他人就去逛街了，等排号的朋友通知我们可以吃饭了，我们就直接去享用了。
# 九、什么是零拷贝？
![image](https://github.com/user-attachments/assets/91530da1-38e6-4bdf-ac61-87cf7066fae6)
1、进程每一次读写操作，用户态到内核态一次，内核态到网卡一次，返回数据再有两次，零拷贝就是解决用户态到内核态的过程，CPU的上下文切换，避免这一过程
2、虚拟内存：将用户控件和内核空间的数据都写到一个地方
3、主要两种实现方式：分别是 mmap+write 方式和 sendfile 方式，
mmap是利用了虚拟内存(划分为用户内存和内核内存)映射到用户空间中,sendfile可以直接从磁盘读取到内核中然后直接从内核发送到网卡,不需要进行用户态和内核态的转换拷贝
# 十、静态代理和动态代理
1、静态代理：比如学生交班费，班长统一收取，然后代替学生上交，这时候班长就属于代理类，那么在代理类就可以在执行上交班费前执行一些其他操作，比如班长在每次上交班费钱，夸一下张三最近表现很好，这就属于代理的好处，静态代理是在程序运行之前编译完成，但是静态代理就需要为每一个接口生成一个代理类，第一重复麻烦，第二个就是学生变了，班长也要变，代理类需要修改代码
2、动态代理：不需要为每一个接口去生成一个代理类，很方便的对代理类的函数进行统一的处理，被代码类变化，代理类未必需要变化，第二解决了重复的问题。代码运行时动态生成的。通过聚合方式持有被代理对象的引用，把外部对invoke的调用最终都转为对被代理对象的调用。
# 十一、动态代理：面向接口编程，屏蔽RPC处理流程
![image](https://github.com/user-attachments/assets/3b45a056-200a-4b36-9a8a-7968ff3cc3d7)
动态代理是一种具体的技术框架，那就会涉及到选型。我们可以从这样三个角度去考虑：
1、因为代理类是在运行中生成的，那么代理框架生成代理类的速度、生成代理类的字节码大小等等，都会影响到其性能——生成的字节码越小，运行所占资源就越小。
2、还有就是我们生成的代理类，是用于接口方法请求拦截的，所以每次调用接口方法的时候，都会执行生成的代理类，这时生成的代理类的执行效率就需要很高效。
3、最后一个是从我们的使用角度出发的，我们肯定希望选择一个使用起来很方便的代理类框架，比如我们可以考虑：API 设计是否好理解、社区活跃度、还有就是依赖复杂度等等。
# 十二、RPC的结构设计
![image](https://github.com/user-attachments/assets/0a58837b-ee92-4745-b689-fa9206bec5c1)
1、考虑到可靠性传输，一般采用TCP协议传输，为了屏蔽网络的复杂性，我们单独封装一个模块，叫传输模块
2、用户的请求是基于方法调用，需要传参，那么急需要序列化数据，还要在必要的位置加上“断句”，这里叫协议封装
3、这两个步骤其实都是为了可靠性传输，那么统一封装好，叫协议模块
4、除此之外可以加入压缩功能，提升传输效率，包的大小超过某个阈值，就启动压缩算法。包的大小可以决定包被拆分成多少数据包等等。
5、为了让两个模块能配合工作，需要写一些粘合性的代码，但是这部分代码对开发人员没有意义，我们需要屏蔽具体细节，让调用远程方法像调用本地一样，这部分我们一般叫做 Bootstrap 模块。
6、上面这些最多算是单机版，服务提供方肯定不是单一的机器，是分集群处理请求的，那么就需要有集群模块
7、考虑到可扩展性，那么就引入插件模块，将功能的接口和功能的实现分离，提供接口的默认实现，符合开闭原则，可扩展性好。

